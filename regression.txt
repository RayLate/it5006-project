def train_test_split(data, target,ratio=0.8):
    # Split data into train-test
    # Split at 2:8
    steps = int(data.shape[0]*ratio)
    data_train = data[:steps]
    data_test = data[steps:]
    steps = len(data_test)
    print(
        f"Train interval : {data_train.index.min()} --- {data_train.index.max()}  (n={len(data_train)})")
    print(
        f"Test interval  : {data_test.index.min()} --- {data_test.index.max()}  (n={len(data_test)})")

    x_train = data_train.iloc[:, 7:]
    x_test = data_test.iloc[:, 7:]
    y_train = data_train[target]
    y_test = data_test[target]
    return x_train, x_test, y_train, y_test, steps

## experimental train_test_split, property price of other property type will be used to predict the outcome of the target property type


def train_test_split_experiment(data, target, ratio=0.8):
    # Split data into train-test
    # Split at 2:8
    steps = int(data.shape[0]*ratio)
    data_train = data[:steps]
    data_test = data[steps:]
    steps = len(data_test)
    print(
        f"Train interval : {data_train.index.min()} --- {data_train.index.max()}  (n={len(data_train)})")
    print(
        f"Test interval  : {data_test.index.min()} --- {data_test.index.max()}  (n={len(data_test)})")

    x_train = data_train.drop(target, axis=1)
    x_test = data_test.drop(target, axis=1)
    y_train = data_train[target]
    y_test = data_test[target]
    return x_train, x_test, y_train, y_test, steps

def forecast(y_train, x_train, lags):
    forecaster = ForecasterAutoreg(
        regressor=RandomForestRegressor(random_state=rng),
        lags=lags
    )
    forecaster.fit(y=y_train, exog=x_train)
    print(forecaster)
    return forecaster


def predict(steps, forecaster, x_test, y_train, y_test, title):
    predictions = forecaster.predict(
        steps=steps, exog=x_test)
    error_mse = mean_squared_error(
        y_true=y_test,
        y_pred=predictions
    )
    print(f"Test error (mse): {error_mse}")

    # Plot
    fig, ax = plt.subplots(figsize=(9, 4))
    y_train.plot(ax=ax, label='train')
    y_test.plot(ax=ax, label='test')
    predictions.plot(ax=ax, label='predictions')
    ax.set_ylabel('Resale SGD per meter sqr')
    ax.set_xlabel('year')
    ax.set_title(title)
    ax.legend()
    return predictions, error_mse

# Hyperparameter Grid search


def hyperparameterTuning(steps, lags, lags_grid, param_grid, y_train, x_train, initial_train_size):
    steps = steps
    forecaster = ForecasterAutoreg(
        regressor=RandomForestRegressor(random_state=rng),
        lags=lags  # This value will be replaced in the grid search
    )

    lags_grid = lags_grid

    param_grid = param_grid

    results_grid = grid_search_forecaster(
        forecaster=forecaster,
        y=y_train,
        exog=x_train,
        param_grid=param_grid,
        lags_grid=lags_grid,
        steps=steps,
        refit=True,
        metric='mean_squared_error',
        initial_train_size=initial_train_size,
        return_best=True,
        verbose=False
    )

    return forecaster, results_grid


def getImportantFeatures(forecaster):
    featuresImportance = forecaster.get_feature_importance()
    featuresImportance = featuresImportance.sort_values(
        'importance', ascending=False)
    featuresImportance = featuresImportance[~featuresImportance['feature'].str.contains(
        'lag')]
    # drop features with importance less than 0.01
    featuresImportance = featuresImportance[featuresImportance['importance'] > 0.01]

    return featuresImportance.feature.to_list()

